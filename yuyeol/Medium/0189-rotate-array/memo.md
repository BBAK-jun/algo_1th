### 공간 복잡도

* **새 배열 방법**: $O(N)$
    * $N$은 배열 `nums`의 길이입니다.
    * `newNums`라는 새로운 배열을 만들고 `nums`의 모든 요소를 복사하므로, 배열 길이에 비례하는 추가 메모리가 필요합니다. 배열이 커질수록 메모리 사용량도 함께 늘어납니다.

* **3단계 뒤집기 방법**: $O(1)$
    * `temp` 변수 하나만 사용하므로, 배열의 크기와 관계없이 항상 일정한 양의 메모리만 사용합니다. 이는 매우 효율적입니다.

### 시간 복잡도

* **새 배열 방법**: $O(N)$
    * `newNums`에 요소를 채우기 위해 `nums` 배열을 한 번 순회하고, `newNums`의 내용을 다시 `nums`에 복사하기 위해 한 번 더 순회합니다. 총 두 번의 순회로 시간 복잡도는 $O(2N)$이 되며, 이는 $O(N)$으로 간주됩니다.

* **3단계 뒤집기 방법**: $O(N)$
    * 배열 전체를 뒤집기 위해 한 번 순회($O(N)$), 앞쪽 `k`개를 뒤집기 위해 한 번 순회($O(k)$), 나머지 `n-k`개를 뒤집기 위해 한 번 순회($O(n-k)$)합니다. 총 순회 횟수는 $N + k + (n-k) = 2N$에 가까우므로, 이 또한 $O(N)$으로 간주됩니다.

---

### 결론

두 방법 모두 **시간 복잡도는 $O(N)$으로 비슷합니다.** 즉, 배열이 커져도 계산에 걸리는 시간은 배열 길이에 거의 비례합니다.

하지만 **공간 복잡도에서 큰 차이**가 납니다. 새 배열을 만드는 방법은 $O(N)$의 추가 메모리를 사용하는 반면, 3단계 뒤집기 방법은 $O(1)$의 메모리만 사용합니다. 따라서, 메모리가 제한적인 환경이나 매우 큰 배열을 다룰 때는 3단계 뒤집기 방법이 성능적으로 훨씬 우수합니다.
